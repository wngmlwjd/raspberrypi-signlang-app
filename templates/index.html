<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Raspberry Pi Camera Stream</title>
</head>
<body>
    <h1>Camera Stream</h1>

    <!-- 녹화 버튼 -->
    <form id="recordForm" method="POST" action="/start_recording">
        <button type="submit">번역 시작</button>
    </form>

    <!-- 녹화 상태 표시 -->
    <p id="status">대기 중</p>

    <!-- 진행 상황 로그 -->
    <pre id="statusLog" style="background:#000; color:#0f0; padding:10px; height:200px; overflow-y:auto; white-space:pre-wrap;"></pre>

    <!-- 추출된 프레임 미리보기 -->
    <div id="framesContainer" style="display:none; margin-bottom:20px;">
        <h3>추출된 프레임</h3>
        <div id="frames" style="display:flex; flex-wrap:wrap; gap:5px;"></div>
    </div>

    <!-- 녹화 영상 재생 -->
    <div id="videoContainer" style="display:none; margin-top:10px;">
        <h3>녹화된 영상</h3>
        <video id="recordedVideo" width="640" height="480" controls>
            <source id="videoSource" src="" type="video/mp4">
            브라우저가 video 태그를 지원하지 않습니다.
        </video>
    </div>

    <script>
    const form = document.getElementById("recordForm");
    const statusEl = document.getElementById("status");
    const statusLog = document.getElementById("statusLog");
    const videoContainer = document.getElementById("videoContainer");
    const videoEl = document.getElementById("recordedVideo");
    const videoSource = document.getElementById("videoSource");
    const framesContainer = document.getElementById("framesContainer");
    const framesDiv = document.getElementById("frames");

    // 녹화 버튼 클릭
    form.addEventListener("submit", async (e) => {
        e.preventDefault();
        statusEl.textContent = "녹화 중...";

        // 영상 초기화
        videoSource.src = "";
        videoContainer.style.display = "none";

        // 프레임 초기화 → 버튼 클릭 시만
        framesDiv.innerHTML = "";
        framesContainer.style.display = "none";
        statusLog.textContent = ""; // ← 로그 초기화

        await fetch("/start_recording", { method: "POST" });
    });

    // 영상 준비 확인 함수
    const waitForVideo = async (url, retries = 10, delay = 500) => {
        for (let i = 0; i < retries; i++) {
            const res = await fetch(url, { method: "HEAD" });
            if (res.ok) return true;
            await new Promise(r => setTimeout(r, delay));
        }
        return false;
    };

    // 녹화 상태 모니터링
    setInterval(async () => {
        const res = await fetch("/recording_status");
        const data = await res.json();

        // 로그 누적
        statusLog.textContent = data.status_log.join("\n");
        statusLog.scrollTop = statusLog.scrollHeight;

        // 마지막 상태를 한 줄 표시
        if (data.status_log.length > 0) {
            statusEl.textContent = data.status_log[data.status_log.length - 1];
        }

        // 영상 자동 재생
        if (data.status_log.includes("프레임 추출 완료") && videoContainer.style.display === "none") {
            const videoUrl = `/recorded_video?time=${new Date().getTime()}`;
            const exists = await waitForVideo(videoUrl);
            if (exists) {
                videoSource.src = videoUrl;
                videoContainer.style.display = "block";
                videoEl.load();
                videoEl.play();

                // 프레임 미리보기 → 영상 재생 후 표시
                if (data.frame_count > 0 && framesContainer.style.display === "none") {
                    framesContainer.style.display = "block";
                    const totalFrames = data.frame_count;
                    const displayCount = 5;
                    const step = Math.floor(totalFrames / displayCount) || 1;

                    for (let i = 0; i < totalFrames && i < displayCount * step; i += step) {
                        const img = document.createElement("img");
                        img.src = `/frames/frame_${i.toString().padStart(5,'0')}.jpg?time=${new Date().getTime()}`;
                        img.width = 120;
                        framesDiv.appendChild(img);
                    }
                }
            }
        }
    }, 1000);
    </script>
</body>
</html>
